You’re running into a session cookie not sticking problem. On Replit (or any split client/server setup) this almost always comes from one of these 4 things:
API and app are on different origins (different port or subdomain) → browser won’t send/set the cookie unless configured exactly right
cookie settings don’t match your traffic (sameSite/secure, missing trust proxy)
the server doesn’t regenerate + save the session at login
the client isn’t sending credentials: 'include' on every auth request
Below is a copy-paste brief you can give the agent to fix it once and for all. No guessing needed.
🔧 “Fix auth completely” brief
A) Make requests same-origin during dev (easiest & most reliable)
In vite.config.ts, proxy the API so your React app hits /api/* on the same origin:
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      '/api': 'http://localhost:3000', // your Express server
    },
  },
});
In the client, call relative paths (/api/login, /api/me, /api/logout) — do not hardcode ports or domains.
If you cannot proxy and must call a different origin: set sameSite: 'none' and cookie.secure = true, configure CORS with credentials: true and an exact origin. But the proxy route is simpler and avoids all this.
B) Session config (Express) – server/routes.ts or server bootstrap
import session from 'express-session';
import pgSession from 'connect-pg-simple';
const PgSession = pgSession(session);

// behind Replit/Netlify/GCP proxies:
app.set('trust proxy', 1);

app.use(session({
  name: 'bgc.sid',
  store: new PgSession({ pool }),        // or { conString: process.env.DATABASE_URL }
  secret: process.env.SESSION_SECRET!,   // set a long, random value
  resave: false,
  saveUninitialized: false,
  rolling: true,
  cookie: {
    httpOnly: true,
    sameSite: 'lax',                     // works with same-origin (via Vite proxy)
    secure: process.env.NODE_ENV === 'production',
    maxAge: 1000 * 60 * 60 * 8,          // 8h
    path: '/',                           // important
  },
}));
Do not set cookie.domain while on replit.dev; let the browser decide.
If you’re calling cross-origin (not recommended), switch sameSite: 'none' and keep secure: true.
C) Login route – regenerate + save session before responding
router.post('/api/login', async (req, res, next) => {
  const { username, password } = req.body;
  const user = await db.getUserByUsername(username);
  if (!user) return res.status(401).json({ error: 'Invalid credentials' });

  const ok = await bcrypt.compare(password, user.password_hash);
  if (!ok) return res.status(401).json({ error: 'Invalid credentials' });

  req.session.regenerate(err => {
    if (err) return next(err);
    req.session.userId = user.id;
    req.session.role  = user.role;
    req.session.save(err2 => {
      if (err2) return next(err2);
      res.json({ ok: true, user: { id: user.id, role: user.role, name: user.name } });
    });
  });
});
Add these helpers:
router.get('/api/me', (req, res) => {
  if (req.session?.userId) return res.json({ id: req.session.userId, role: req.session.role });
  res.status(401).json({ error: 'unauthenticated' });
});

router.post('/api/logout', (req, res) => {
  req.session.destroy(() => res.json({ ok: true }));
});
D) CORS (only if NOT proxying)
import cors from 'cors';
app.use(cors({
  origin: 'https://<your-client-url>',  // exact URL
  credentials: true,
}));
E) Client – always include credentials, refresh me, then navigate
In your fetch/axios wrapper:
// fetch
fetch('/api/login', {
  method: 'POST',
  credentials: 'include',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ username, password })
});

// axios
axios.defaults.withCredentials = true;
In client/src/hooks/useAuth.ts (or your login mutation):
const login = useMutation({
  mutationFn: (payload) => fetch('/api/login', { method:'POST', credentials:'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)}).then(r => r.json()),
  onSuccess: async () => {
    await queryClient.invalidateQueries({ queryKey: ['me'] });
    router.navigate('/dashboard'); // only after /me returns authenticated
  }
});
F) Quick test (no UI)
Login
curl -i -X POST http://localhost:5173/api/login -H 'Content-Type: application/json' --data '{"username":"admin","password":"admin123"}'
Expect Set-Cookie: bgc.sid=...; Path=/; HttpOnly; SameSite=Lax
Use cookie
curl -i http://localhost:5173/api/me -H 'Cookie: bgc.sid=<value from Set-Cookie>'
Expect 200 with the user JSON.
Logout
curl -i -X POST http://localhost:5173/api/logout -H 'Cookie: bgc.sid=<value>'
If step 1 shows no Set-Cookie, you’re still cross-origin or cookie settings don’t match. If step 2 returns 401 with the same cookie, your session store or trust proxy is wrong.